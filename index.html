<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universal Review Aggregator + Sentiment Analysis</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacOSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
            color: #333;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #1a1a1a;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
            margin: 1rem 0 0.5rem 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .btn {
            display: block;
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.2s;
            margin: 1rem 0;
            text-align: center;
            width: 100%;
        }
        .btn:hover {
            background: #0056b3;
        }
        #loading {
            display: none;
            text-align: center;
            font-size: 1.2rem;
            margin: 2rem 0;
        }
        #result {
            margin-top: 2rem;
        }
        #result h2, #result h3 {
            margin-top: 1.8rem;
        }
        ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        .sentiment-box {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: bold;
            text-align: center;
        }
        .very-positive { background: #d4edda; color: #155724; }
        .positive     { background: #e2f3e2; color: #155724; }
        .neutral      { background: #fff3cd; color: #856404; }
        .negative     { background: #f8d7da; color: #721c24; }
        .very-negative{ background: #e74c3c; color: white; }
        footer {
            text-align: center;
            margin-top: 3rem;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Universal Review Aggregator + Sentiment</h1>
    <p style="text-align:center; font-size:1.1rem; color:#555;">
        Aggregates reviews + performs client-side sentiment analysis<br>
        (No API key • Pure browser + your CORS proxy • Free)
    </p>

    <label for="proxy">CORS Proxy URL (e.g. https://your-worker.workers.dev/corsproxy/?apiurl=):</label>
    <input type="text" id="proxy" placeholder="Enter your Cloudflare Worker proxy URL" value="" required />

    <label for="product">Product / Item Name:</label>
    <input type="text" id="product" placeholder="Example: iPhone 16 Pro, Breaking Bad, Tesla..." autofocus required />

    <button class="btn" onclick="getReview()">Analyze Reviews & Sentiment</button>

    <div id="loading">Loading reviews & computing sentiment...</div>
    <div id="result"></div>
</div>

<footer>
    Pure client-side • Host free on GitHub Pages • Sentiment: simple rule-based (AFINN-inspired)
</footer>

<script>
// === Basic Client-side Sentiment Analyzer (AFINN-inspired) ===
const positiveWords = [
    'good', 'great', 'excellent', 'awesome', 'amazing', 'love', 'best', 'fantastic', 'perfect', 'wonderful',
    'nice', 'happy', 'beautiful', 'superb', 'outstanding', 'brilliant', 'impressive', 'recommend', 'worth',
    'solid', 'top', 'favorite', 'enjoy', 'like', 'cool', 'incredible', 'stellar'
];

const negativeWords = [
    'bad', 'worst', 'terrible', 'awful', 'poor', 'disappointing', 'hate', 'problem', 'issue', 'fail',
    'broken', 'slow', 'expensive', 'overrated', 'waste', 'boring', 'ugly', 'weak', 'avoid', 'sucks',
    'garbage', 'trash', 'mediocre', 'pathetic', 'frustrating', 'annoying'
];

const negationWords = ['not', 'no', 'never', 'none', 'nothing', "don't", "doesn't", "isn't", "wasn't", "aren't"];

function analyzeSentiment(text) {
    if (!text) return { score: 0, label: 'Neutral' };

    const words = text.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
    let score = 0;
    let wordCount = 0;

    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        if (positiveWords.includes(word)) {
            score += 1;
            wordCount++;
        } else if (negativeWords.includes(word)) {
            let negated = false;
            // Simple negation check (look back 1-3 words)
            for (let j = Math.max(0, i-3); j < i; j++) {
                if (negationWords.includes(words[j])) {
                    negated = true;
                    break;
                }
            }
            score += negated ? 1 : -1;
            wordCount++;
        }
    }

    const normalized = wordCount > 0 ? score / wordCount : 0;
    // Map -1..+1 → 0..10
    const rating10 = Math.round(((normalized + 1) / 2) * 10 * 10) / 10;

    let label = 'Neutral';
    if (normalized > 0.4) label = 'Very Positive';
    else if (normalized > 0.15) label = 'Positive';
    else if (normalized < -0.4) label = 'Very Negative';
    else if (normalized < -0.15) label = 'Negative';

    return { score: normalized, rating10, label, wordCount };
}

// === Main logic ===
const input = document.getElementById('product');
const proxyInput = document.getElementById('proxy');
const loading = document.getElementById('loading');
const result = document.getElementById('result');

async function getReview() {
    const product = input.value.trim();
    const proxy = proxyInput.value.trim();

    if (!product || !proxy) {
        alert("Please enter both product name and proxy URL.");
        return;
    }

    loading.style.display = 'block';
    result.innerHTML = '';

    try {
        // 1. Fetch rating-related info
        const ratingData = await fetchProxy(proxy, `https://api.duckduckgo.com/?q=${encodeURIComponent(product + ' average rating review site:reddit.com OR site:amazon.com OR site:trustpilot.com OR site:metacritic.com')}&format=json`);
        const rating = extractRating(ratingData);

        // 2. Fetch general review text for sentiment & pros/cons
        const reviewData = await fetchProxy(proxy, `https://api.duckduckgo.com/?q=${encodeURIComponent(product + ' review pros cons highlights')}&format=json`);

        // Combine all possible text sources for sentiment
        const allText = [
            reviewData.AbstractText || '',
            ...(reviewData.RelatedTopics || []).map(t => t.Text || '')
        ].join(' ').replace(/\s+/g, ' ').trim();

        const sentiment = analyzeSentiment(allText);

        // 3. Extract structured info (same as before)
        const { positives, negatives } = extractProsCons(reviewData);
        const { highlights, lowlights } = extractHighlightsLowlights(reviewData);

        // 4. Final recommendation with sentiment influence
        let finalScore = rating || 5;
        if (sentiment.rating10) {
            finalScore = Math.round((finalScore * 0.6 + sentiment.rating10 * 0.4) * 10) / 10; // blend
        }
        const recommendation = finalScore >= 7.5 ? 'Strongly Recommended' :
                              finalScore >= 6 ? 'Recommended' :
                              finalScore >= 4 ? 'Mixed – Consider alternatives' : 'Not Recommended';

        // 5. Render
        let sentimentClass = sentiment.label.toLowerCase().replace(/\s+/g, '-');

        result.innerHTML = `
            <h2>Review Summary for <em>${product}</em></h2>

            <div class="sentiment-box ${sentimentClass}">
                Overall Sentiment: ${sentiment.label} (score ≈ ${sentiment.score.toFixed(2)})
                → Converted to scale: ${sentiment.rating10 ? sentiment.rating10.toFixed(1) + '/10' : 'N/A'}
            </div>

            <p><strong>Extracted Average Rating:</strong> ${rating ? rating + '/10' : 'N/A'} (from web sources)</p>
            <p><strong>Blended Final Rating:</strong> <strong>${finalScore.toFixed(1)}/10</strong></p>

            <h3>Highlights</h3>
            <ul>${highlights.map(h => `<li>${h}</li>`).join('') || '<li>No highlights detected.</li>'}</ul>

            <h3>Lowlights</h3>
            <ul>${lowlights.map(l => `<li>${l}</li>`).join('') || '<li>No lowlights detected.</li>'}</ul>

            <h3>Positives</h3>
            <ul>${positives.map(p => `<li>${p}</li>`).join('') || '<li>No clear positives found.</li>'}</ul>

            <h3>Negatives</h3>
            <ul>${negatives.map(n => `<li>${n}</li>`).join('') || '<li>No clear negatives found.</li>'}</ul>

            <h3>Final Recommendation</h3>
            <p style="font-size:1.3rem; font-weight:bold;">${recommendation}</p>
        `;

    } catch (error) {
        result.innerHTML = `<p style="color: red;">Error: ${error.message}. Check proxy URL / internet.</p>`;
    } finally {
        loading.style.display = 'none';
    }
}

async function fetchProxy(proxy, target) {
    const url = proxy + encodeURIComponent(target);
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Proxy fetch failed: ${response.status}`);
    return await response.json();
}

function extractRating(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' ')).toLowerCase();
    const match = text.match(/(\d+(\.\d+)?)\s*(?:out of|\/|of|stars?|rating|score)/i);
    if (match) {
        let r = parseFloat(match[1]);
        if (r <= 5) r *= 2;
        if (r > 10 && r <= 100) r /= 10;
        return Math.min(10, Math.max(0, Math.round(r * 10) / 10));
    }
    return null;
}

function extractProsCons(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' '));
    const positives = extractList(text, ['pros:', 'positives:', 'advantages:', 'good:', 'strengths:']);
    const negatives = extractList(text, ['cons:', 'negatives:', 'disadvantages:', 'bad:', 'weaknesses:', 'problems:']);
    return { positives, negatives };
}

function extractHighlightsLowlights(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' '));
    const highlights = extractList(text, ['highlights:', 'best', 'pros:', 'top features:']);
    const lowlights = extractList(text, ['lowlights:', 'worst', 'cons:', 'issues:']);
    return { highlights, lowlights };
}

function extractList(text, starters) {
    const lower = text.toLowerCase();
    for (const starter of starters) {
        const idx = lower.indexOf(starter);
        if (idx !== -1) {
            const slice = text.substring(idx + starter.length, idx + starter.length + 600).trim();
            return slice.split(/[\n•\-\•|]/).map(s => s.trim()).filter(s => s.length > 3 && s.length < 120);
        }
    }
    return [];
}

// Enter key support
document.getElementById('product').addEventListener('keypress', e => {
    if (e.key === 'Enter') getReview();
});
</script>
</body>
</html>
