<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Universal Review Aggregator + TF.js Sentiment</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacOSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
            color: #333;
            line-height: 1.6;
        }
        h1 { text-align: center; color: #1a1a1a; }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
            margin: 1rem 0 0.5rem 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .btn {
            display: block;
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.2s;
            margin: 1rem 0;
            text-align: center;
            width: 100%;
        }
        .btn:hover { background: #0056b3; }
        #loading { display: none; text-align: center; font-size: 1.2rem; margin: 2rem 0; }
        #result { margin-top: 2rem; }
        #result h2, #result h3 { margin-top: 1.8rem; }
        ul { list-style-type: disc; padding-left: 20px; }
        .sentiment-box {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: bold;
            text-align: center;
            font-size: 1.2rem;
        }
        .very-positive { background: #d4edda; color: #155724; }
        .positive     { background: #e2f3e2; color: #155724; }
        .neutral      { background: #fff3cd; color: #856404; }
        .negative     { background: #f8d7da; color: #721c24; }
        .very-negative{ background: #e74c3c; color: white; }
        footer {
            text-align: center;
            margin-top: 3rem;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Universal Review Aggregator + TensorFlow.js Sentiment</h1>
    <p style="text-align:center; font-size:1.1rem; color:#555;">
        Aggregates reviews from web + deep learning sentiment analysis in browser<br>
        (No API key • Uses official TF.js IMDB model • Your CORS proxy)
    </p>

    <label for="proxy">CORS Proxy URL (required for DuckDuckGo fetches):</label>
    <input type="text" id="proxy" placeholder="https://your-worker.workers.dev/corsproxy/?apiurl=" value="" required />

    <label for="product">Product / Item Name:</label>
    <input type="text" id="product" placeholder="Example: iPhone 16 Pro Max, Cyberpunk 2077, MrBeast..." autofocus required />

    <button class="btn" onclick="getReview()">Analyze Reviews & Sentiment</button>

    <div id="loading">Loading model & analyzing reviews... (first time may take 10–20 sec)</div>
    <div id="result"></div>
</div>

<footer>
    Pure client-side • TensorFlow.js CNN sentiment model (IMDB) • Host free on GitHub Pages
</footer>

<script>
let model = null;
let metadata = null;

// Lazy-load TF.js sentiment model & metadata once
async function loadSentimentModel() {
    if (model) return; // already loaded

    const MODEL_URL = 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/model.json';
    const METADATA_URL = 'https://storage.googleapis.com/tfjs-models/tfjs/sentiment_cnn_v1/metadata.json';

    try {
        document.getElementById('loading').innerText = 'Loading TensorFlow.js sentiment model...';
        model = await tf.loadLayersModel(MODEL_URL);
        
        const metaResponse = await fetch(METADATA_URL);
        metadata = await metaResponse.json();
        
        document.getElementById('loading').innerText = 'Model loaded! Analyzing...';
    } catch (err) {
        throw new Error('Failed to load TF.js model: ' + err.message);
    }
}

function padSequences(sequences, maxLen, padding = 'pre', truncating = 'pre', value = 0) {
    return sequences.map(seq => {
        if (seq.length > maxLen) {
            if (truncating === 'pre') return seq.slice(seq.length - maxLen);
            return seq.slice(0, maxLen);
        }
        const padLen = maxLen - seq.length;
        const padArray = new Array(padLen).fill(value);
        return padding === 'pre' ? [...padArray, ...seq] : [...seq, ...padArray];
    });
}

async function predictSentiment(text) {
    if (!model || !metadata) throw new Error('Model not loaded');

    const words = text.toLowerCase().trim().split(/\s+/).slice(0, metadata.max_len);
    const wordIndices = words.map(w => {
        const idx = metadata.word_index[w];
        return idx != null ? idx + metadata.padding_idx : 0; // 0 = OOV
    });

    const sequence = padSequences([wordIndices], metadata.max_len, 'pre', 'pre', 0)[0];

    const inputTensor = tf.tensor2d([sequence], [1, metadata.max_len]);
    const prediction = model.predict(inputTensor);
    const score = (await prediction.data())[0]; // 0→1 (neg→pos)

    inputTensor.dispose();
    prediction.dispose();

    return score;
}

// Map TF.js score (0-1) → 0-10 scale + label
function getSentimentInfo(score) {
    const rating10 = Math.round(score * 10 * 10) / 10;
    let label = 'Neutral';
    let cssClass = 'neutral';

    if (score >= 0.75) { label = 'Very Positive'; cssClass = 'very-positive'; }
    else if (score >= 0.60) { label = 'Positive'; cssClass = 'positive'; }
    else if (score <= 0.40) { label = 'Very Negative'; cssClass = 'very-negative'; }
    else if (score <= 0.25) { label = 'Negative'; cssClass = 'negative'; }

    return { score, rating10, label, cssClass };
}

// === Main analysis function ===
const input = document.getElementById('product');
const proxyInput = document.getElementById('proxy');
const loading = document.getElementById('loading');
const resultDiv = document.getElementById('result');

async function getReview() {
    const product = input.value.trim();
    const proxy = proxyInput.value.trim();

    if (!product || !proxy) {
        alert("Please enter product name and CORS proxy URL.");
        return;
    }

    loading.style.display = 'block';
    resultDiv.innerHTML = '';

    try {
        await loadSentimentModel(); // ensure model is ready

        // Fetch review-related info
        const reviewQuery = `${product} review pros cons highlights lowlights rating`;
        const data = await fetchProxy(proxy, `https://api.duckduckgo.com/?q=${encodeURIComponent(reviewQuery)}&format=json`);

        // Combine all text for sentiment
        const allText = [
            data.AbstractText || '',
            ...(data.RelatedTopics || []).map(t => t.Text || '')
        ].join(' ').replace(/\s+/g, ' ').trim();

        // Get TF.js sentiment
        const tfScore = await predictSentiment(allText);
        const sentiment = getSentimentInfo(tfScore);

        // Extract rating if possible
        const rating = extractRating(data);

        // Structured parts
        const { positives, negatives } = extractProsCons(data);
        const { highlights, lowlights } = extractHighlightsLowlights(data);

        // Blend scores (sentiment has more weight since it's deeper)
        let finalScore = rating ? (rating * 0.4 + sentiment.rating10 * 0.6) : sentiment.rating10;
        finalScore = Math.min(10, Math.max(0, Math.round(finalScore * 10) / 10));

        const recommendation = finalScore >= 7.5 ? 'Strongly Recommended' :
                              finalScore >= 6 ? 'Recommended' :
                              finalScore >= 4 ? 'Mixed – Consider alternatives' : 'Not Recommended';

        resultDiv.innerHTML = `
            <h2>Review Summary for <em>${product}</em></h2>

            <div class="sentiment-box ${sentiment.cssClass}">
                TF.js Deep Sentiment: ${sentiment.label} (${(sentiment.score * 100).toFixed(0)}% positive)
                → Scale: ${sentiment.rating10.toFixed(1)}/10
            </div>

            <p><strong>Extracted Web Rating:</strong> ${rating ? rating + '/10' : 'N/A'}</p>
            <p><strong>Final Blended Rating:</strong> <strong style="font-size:1.4rem;">${finalScore.toFixed(1)}/10</strong></p>

            <h3>Highlights</h3>
            <ul>${highlights.map(h => `<li>${h}</li>`).join('') || '<li>No highlights detected.</li>'}</ul>

            <h3>Lowlights</h3>
            <ul>${lowlights.map(l => `<li>${l}</li>`).join('') || '<li>No lowlights detected.</li>'}</ul>

            <h3>Positives</h3>
            <ul>${positives.map(p => `<li>${p}</li>`).join('') || '<li>No clear positives found.</li>'}</ul>

            <h3>Negatives</h3>
            <ul>${negatives.map(n => `<li>${n}</li>`).join('') || '<li>No clear negatives found.</li>'}</ul>

            <h3>Recommendation</h3>
            <p style="font-size:1.3rem; font-weight:bold;">${recommendation}</p>
        `;

    } catch (error) {
        resultDiv.innerHTML = `<p style="color: red;">Error: ${error.message}<br>Check proxy / internet / ad-blocker.</p>`;
    } finally {
        loading.style.display = 'none';
    }
}

async function fetchProxy(proxy, target) {
    const url = proxy + encodeURIComponent(target);
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Proxy error: ${response.status}`);
    return await response.json();
}

// The same helper functions as before (extractRating, extractProsCons, extractHighlightsLowlights)
function extractRating(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' ')).toLowerCase();
    const match = text.match(/(\d+(\.\d+)?)\s*(?:out of|\/|of|stars?|rating|score)/i);
    if (match) {
        let r = parseFloat(match[1]);
        if (r <= 5) r *= 2;
        if (r > 10 && r <= 100) r /= 10;
        return Math.min(10, Math.max(0, Math.round(r * 10) / 10));
    }
    return null;
}

function extractProsCons(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' '));
    const positives = extractList(text, ['pros:', 'positives:', 'advantages:', 'good:', 'strengths:']);
    const negatives = extractList(text, ['cons:', 'negatives:', 'disadvantages:', 'bad:', 'weaknesses:', 'problems:']);
    return { positives, negatives };
}

function extractHighlightsLowlights(data) {
    const text = (data.AbstractText + ' ' + (data.RelatedTopics || []).map(t => t.Text || '').join(' '));
    const highlights = extractList(text, ['highlights:', 'best', 'pros:', 'top features:']);
    const lowlights = extractList(text, ['lowlights:', 'worst', 'cons:', 'issues:']);
    return { highlights, lowlights };
}

function extractList(text, starters) {
    const lower = text.toLowerCase();
    for (const starter of starters) {
        const idx = lower.indexOf(starter);
        if (idx !== -1) {
            const slice = text.substring(idx + starter.length, idx + starter.length + 600).trim();
            return slice.split(/[\n•\-\•|]/).map(s => s.trim()).filter(s => s.length > 3 && s.length < 120);
        }
    }
    return [];
}

// Enter key support
document.getElementById('product').addEventListener('keypress', e => {
    if (e.key === 'Enter') getReview();
});
</script>
</body>
</html>
